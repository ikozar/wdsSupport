/*
 * (c) Copyright 2005-2013 JAXIO, http://www.jaxio.com
 * Source code generated by Celerio, a Jaxio product
 * Want to use Celerio within your company? email us at info@jaxio.com
 * Follow us on twitter: @springfuse
 * Template pack-backend-jpa:src/main/java/project/dao/support/GenericDao.p.vm.java
 */
package ru.ki.dao.support;

//import com.sun.istack.internal.NotNull;
import org.apache.commons.beanutils.ConvertUtils;
import org.apache.commons.beanutils.ConvertUtilsBean;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.Validate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import ru.ki.MyStringUtils;
import ru.ki.dao.support.dozer.DozerSupport;

import javax.annotation.PostConstruct;
import javax.persistence.*;
import javax.persistence.criteria.*;
import javax.persistence.metamodel.ManagedType;
import javax.persistence.metamodel.SingularAttribute;
import java.io.Serializable;
import java.text.MessageFormat;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

import static com.google.common.collect.Iterables.toArray;
import static com.google.common.collect.Lists.newArrayList;

/**
 * JPA 2 Generic DAO with find by example/range/pattern and CRUD support. 
 */
public abstract class GenericDao<E, PK extends Serializable> {
    static final public String ROOT = "ROOT";

    @PersistenceContext
    private EntityManager entityManager;

    @Autowired(required = true)
    private DozerSupport dozerSupport;

    private Class<E> type;
    private Logger log;
    private String cacheRegion;

    protected EntityManager getEntityManager() {
        return entityManager;
    }

    /**
     * This constructor needs the real type of the generic type E so it can be passed to the {@link javax.persistence.EntityManager}.
     */
    public GenericDao(Class<E> type) {
        this.type = type;
        this.log = LoggerFactory.getLogger(getClass());
        this.cacheRegion = type.getCanonicalName();
    }

    @SuppressWarnings("unchecked")
//    public <T> FindResult<T> find(SearchParameters sp, @NotNull Class<T> typeReturn) {
    public <T> FindResult<T> find(SearchParameters sp, Class<T> typeReturn) {
/*
        if (sp.hasNamedQuery()) {
            return getNamedQueryUtil().findByNamedQuery(sp);
        }
*/
        FindResult<T> findResult = new FindResult<T>(dozerSupport);

        CriteriaBuilder builder = entityManager.getCriteriaBuilder();
        CriteriaQuery criteriaQuery;
        if (sp.isCustomSelect()) {
            criteriaQuery = builder.createQuery(Tuple.class);
        } else {
            criteriaQuery = builder.createQuery(type);
        }
        // criteriaQuery.distinct(true); // TODO: when active, breaks the sort on x-to-one property!

        Map<String, From> joins = new LinkedHashMap<String, From>();
        joins.put(ROOT, criteriaQuery.from(type));
        Predicate predicate = getPredicate(joins, builder, sp);
        if (predicate != null) {
            criteriaQuery = criteriaQuery.where(predicate);
        }

        if (sp.isCustomSelect()) {
            criteriaQuery.multiselect(getSelections(sp, joins));
        }

        // order by
//        criteriaQuery.orderBy(buildJpaOrders(sp.getOrders(), root, builder));

        TypedQuery typedQuery = entityManager.createQuery(criteriaQuery);
        setCacheHints(typedQuery, sp);          // cache

        if (sp.isPagination()) {
            if (sp.getFirstResult() >= 0) {
                typedQuery.setFirstResult(sp.getFirstResult());
            }
            if (sp.getMaxResults() > 0) {
                typedQuery.setMaxResults(sp.getMaxResults());
            }
        }

        findResult.setResultList(typedQuery.getResultList(), typeReturn);

        if (sp.isGetCount()) {
            builder = entityManager.getCriteriaBuilder();
            CriteriaQuery<Long> criteriaQueryCount = builder.createQuery(Long.class);
            // criteriaQuery.distinct(true); // TODO: not taken into account !

            joins.clear();
            joins.put(ROOT, criteriaQueryCount.from(type));
            predicate = getPredicate(joins, builder, sp);
            if (predicate != null) {
                criteriaQueryCount = criteriaQueryCount.where(predicate);
            }

            // count
            criteriaQueryCount = criteriaQueryCount.select(builder.count(joins.get(ROOT)));

            if (predicate != null) {
                criteriaQueryCount = criteriaQueryCount.where(predicate);
            }

            TypedQuery<Long> countQuery = entityManager.createQuery(criteriaQueryCount);
            setCacheHints(countQuery, sp);

            findResult.setCount(countQuery.getSingleResult());
        }

        if (log.isDebugEnabled()) {
            log.debug("Returned " + findResult.getCountResult() + " from " +
                findResult.getCount() + " elements of " + typeReturn.getSimpleName());
        }

        return findResult;
    }

    private List<Selection<?>> getSelections(SearchParameters sp, Map<String, From> joins) {
        if (!sp.isCustomSelect() || sp.getSelectElements().isEmpty()) {
            return Collections.EMPTY_LIST;
        }
        List<Selection<?>> selectionList = new ArrayList<Selection<?>>();
        for (SelectElement se : sp.getSelectElements()) {
            String name = se.getFieldName();
            String[] names = MyStringUtils.splitOnLastSeparator(name, '.');
            From from;
            if (names == null) {
                from = joins.get(ROOT);
            } else {
                from = findJoin(names[0], joins);
                name = names[1];
            }
            selectionList.add(from.get(name).alias(se.getAlias()));
        }
        return selectionList;
    }

    public E get(PK id) {
        if (id == null) {
            return null;
        }

        E entityFound = getEntityManager().find(type, id);

        if (entityFound == null) {
            log.warn("get returned null with pk=" + id);
        }

        return entityFound;
    }

    public Class<E> getJavaType() {
        return type;
    }

    public void refresh(E entity) {
        if (entityManager.contains(entity)) {
            entityManager.refresh(entity);
        }
    }

    public E findUnique(E entity, SearchParameters sp) {
        E result = findUniqueOrNone(entity, sp);

        if (result == null) {
            throw new NoResultException("Developper: You expected 1 result but we found none ! sample: " + entity);
        }

        return result;
    }

    /**
     * We request at most 2, if there's more than one then we throw a  {@link javax.persistence.NonUniqueResultException}
     * @throws javax.persistence.NonUniqueResultException
     */
    public E findUniqueOrNone(E entity, SearchParameters sp) {
        // this code is an optimization to prevent using a count
        sp.setFirstResult(0);
        sp.setMaxResults(2);
        List<E> results = Collections.EMPTY_LIST;   // find(sp);

        if (results == null || results.isEmpty()) {
            return null;
        }

        if (results.size() > 1) {
            throw new NonUniqueResultException("Developper: You expected 1 result but we found more ! sample: " + entity);
        }

        return results.iterator().next();
    }

    private From findJoin(String name, Map<String, From> joins) {
        From from = joins.get(name);
        if (from == null) {
            String[] names = MyStringUtils.splitOnLastSeparator(name, '.');
            if (names == null) {
                from = joins.get(ROOT).join(name);
                from.alias(name + '_' + joins.size());
            } else {
                from = findJoin(names[0], joins);
                from = from.join(names[1]);
                from.alias(names[1] + '_' + joins.size());
            }
            joins.put(name, from);
        }
        return from;
    }


//----------------------------------------------------
    protected <R> Predicate getPredicate(Map<String, From> joins, CriteriaBuilder builder, SearchParameters sp) {
        From from;
        joins.get(ROOT).alias(ROOT);

        List<Predicate> predicates = new ArrayList<Predicate>(sp.getParameters().size());
        boolean repeat = false;
        FilterElement param = null;
        String name = null;
        for (Iterator<FilterElement> iterator = sp.getParameters().iterator(); true; ) {
            if (!repeat) {
                if (!iterator.hasNext())
                    break;
                param = iterator.next();
                name = param.getFieldName();
            }
            repeat = false;
            if (name.contains(".")) {
                String[] names = MyStringUtils.splitOnLastSeparator(name, '.');
                from = findJoin(names[0], joins);
                name = names[1];
            } else {
                from = joins.get(ROOT);
            }
            Path att = null;
            try {
                att = from.get(name);
            } catch (IllegalArgumentException e) {
                SelectElement se = sp.findSelectElementByAlias(name);
                if (se != null && !name.equals(se.getFieldName())) {
                    repeat = true;
                    name = se.getFieldName();
                } else {
                    log.error("Not found field " + name + " for restriction");
                }
                continue;
            }
            if (!att.getJavaType().isAssignableFrom(param.values.get(0).getValue().getClass())) {
                for (int ip=0; ip<param.values.size(); ip++) {
                    param.values.get(ip).convertTo(att.getJavaType());
                }
            }
            predicates.add(param.operator.getCriterion(att, builder, param.values));
        }

      return builder.and(toArray(predicates, Predicate.class));
    }

    /**
     * You may override this method to add a Predicate to the default find method.
     */
    protected <R> Predicate getExtraPredicate(Root<E> root, CriteriaQuery<R> query, CriteriaBuilder builder, E entity, SearchParameters sp) {
        return null;
    }

    /**
     * Save or update the passed entity E to the repository.
     * 
     * @param entity the entity to be saved or updated.
     */
    public void save(E entity) {
        Validate.notNull(entity, "The entity to save cannot be null element");

/*
        // creation with auto generated id
        if (!entity.isIdSet()) {
            getEntityManager().persist(entity);
            return;
        }
*/
      getEntityManager().persist(entity);
    }

    /**
     * Merge the state of the given entity into the current persistence context.
     */
    public E merge(E entity) {
        return getEntityManager().merge(entity);
    }

    /**
     * Delete the passed entity E from the repository.
     * 
     * @param entity the entity to be deleted.
     */
    public void delete(E entity) {
        if (getEntityManager().contains(entity)) {
            getEntityManager().remove(entity);
/*
        } else {
            // could be a delete on a transient instance
            E entityRef = getEntityManager().getReference(type, entity.getId());

            if (entityRef != null) {
                getEntityManager().remove(entityRef);
            } else {
                log.warn("Attempt to delete an instance that is not present in the database: " + entity.toString());
            }
*/
        }
    }

    // -----------------
    // Commons
    // -----------------

    /**
     * Set hints for 2d level cache.
     */
    protected void setCacheHints(TypedQuery<?> typedQuery, SearchParameters sp) {
        if (sp.isCacheable()) {
            typedQuery.setHint("org.hibernate.cacheable", true);

            if (sp.hasCacheRegion()) {
                typedQuery.setHint("org.hibernate.cacheRegion", sp.getCacheRegion());
            } else {
                typedQuery.setHint("org.hibernate.cacheRegion", cacheRegion);
            }
        }
    }

    // -----------------
    // Hibernate Search
    // -----------------
    protected String[] getIndexedFields() {
        return new String[0];
    }
}